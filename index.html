<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Đánh bài cùng Bích Ngân ^_^ </title>
<style>
  body { 
    text-align: center; 
    margin: 0; 
    padding: 0; 
  }
  #header {
    font-size: 10px; /* Downsize font */
    margin-top: 5px; 
    margin-bottom: 5px;
  }
  table { 
    margin: auto; 
    border: 1px solid black; 
    border-collapse: collapse; 
    width: 90%; /* 90% width to fit the screen */
  }
  th, td { 
    padding: 5px; 
    text-align: center; 
    box-sizing: border-box; /* Include padding in width calculation */
    word-wrap: break-word; /* Allow text to wrap within cells */
  }
  th { 
    background-color: #f2f2f2; 
  }
  input[type="number"], input[type="text"] { 
    width: 20%; /* Full width */
    box-sizing: border-box; /* Include padding in width calculation */
    text-align: center; /* Center text */
  }
  .score-positive { color: green; }
  .score-negative { color: red; }
  .score-neutral { color: grey; }
  .check-positive { color: green; }
  .check-negative { color: red; }
  .total-score { font-size: 24px; font-weight: bold; } /* Increased font size and bold */
  button {
    margin-top: 10px;
    font-size: 30px; /* Increase font size */
    padding: 10px 20px; /* Increase padding for larger buttons */
  }
  @media (max-width: 600px) {
    .total-score { font-size: 18px; } /* Adjust font size for smaller screens */
    button { font-size: 30px; padding: 8px 16px; } /* Adjust button size */
    th, td { padding: 3px; } /* Reduce padding for smaller screens */
  }

  /* Add styles for sticky header */
  #scoreTable thead, #scoreTable thead th {
    position: sticky;
    top: 0;
    background-color: #f2f2f2;
    z-index: 10;
    font-size: 30px;
  }

  /* Ensure the total score row is also sticky */
  #scoreTable tr:nth-child(2), #scoreTable tr:nth-child(2) td {
    position: sticky;
    top: 23px; /* Adjust this value based on the height of the first row */
    background-color: white;
    z-index: 5;
  }
</style>
</head>
<body>

<div id="header">------ Nam Vo ------</div>

<table id="scoreTable">
  <thead>
    <tr>
      <th></th>
      <th><input type="text" id="name-0" value="Bích Ngân" onblur="setName(0)"></th>
      <th><input type="text" id="name-1" value="Phương Nam" onblur="setName(1)"></th>
      <th><input type="text" id="name-2" value="Cẩm Lệ" onblur="setName(2)"></th>
      <th><input type="text" id="name-3" value="Nhật Nam" onblur="setName(3)"></th>
    </tr>
    <tr>
      <td></td>
      <td><span id="total-score-0" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-1" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-2" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-3" class="score-neutral total-score">0</span></td>
    </tr>
  </thead>
  <tbody>
    <!-- The rest of your rows will go here -->
  </tbody>
</table>

<button onclick="enterPoints()">Enter Points</button>
<button onclick="completeScores()">Complete</button>
<button onclick="resetGame()">Reset</button>

<br>
<button onclick="exportExcel()">Export Excel</button>

<!-- XLSX with style support -->
<script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.full.min.js"></script>

<script>
  var STORAGE_KEY = "scoreTable_save_v1";

  function saveGame() {
    var table = document.getElementById("scoreTable");
    var data = { headers: [], rows: [] };

    // Save headers (name row): keep whether it's still an input or already turned into text
    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var input = th.querySelector("input");
      if (input) {
        data.headers.push({ isInput: true, value: input.value });
      } else {
        data.headers.push({ isInput: false, value: th.innerHTML });
      }
    }

    // Save all score rows + check column (start from row 2 because row 0/1 are header + totals)
    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var rowObj = { check: row.cells[0].innerHTML, scores: [] };
      for (var c = 1; c <= 4; c++) {
        var cellInput = row.cells[c].firstChild;
        rowObj.scores.push(cellInput ? (cellInput.value || "") : "");
      }
      data.rows.push(rowObj);
    }

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function attachAutoSaveToExistingInputs() {
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) {
        inp.addEventListener("input", saveGame);
      });
    }
  }

  function loadGame() {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    var data = JSON.parse(raw);
    var table = document.getElementById("scoreTable");

    // Restore headers
    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var h = data.headers[i];

      if (h && h.isInput) {
        th.innerHTML = '<input type="text" id="name-' + i + '" value="' + (h.value || "") + '" onblur="setName(' + i + ')">';
      } else {
        th.innerHTML = (h && h.value != null) ? h.value : th.innerHTML;
      }
    }

    // Remove existing score rows (if any)
    while (table.rows.length > 2) {
      table.deleteRow(-1);
    }

    // Restore rows
    if (data.rows && data.rows.length) {
      data.rows.forEach(function(r) {
        var row = table.insertRow(-1);
        var checkCell = row.insertCell(0);
        checkCell.innerHTML = r.check || '';

        for (var i = 1; i <= 4; i++) {
          var cell = row.insertCell(i);
          // Keep original styling behavior via the same input type + CSS
          cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
          var inp = cell.firstChild;
          inp.value = (r.scores && r.scores[i - 1] != null) ? r.scores[i - 1] : "";
          inp.addEventListener("input", saveGame);
        }
      });
    }

    // Recompute totals/colors/checks exactly like before, then save current state (including O/X)
    completeScores();
    saveGame();
  }

  function resetGame() {
    if (!confirm("Bạn có chắc muốn reset để tạo game mới và xoá hết dữ liệu cũ không?")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  }

  function setName(index) {
    var input = document.getElementById("name-" + index);
    var name = input.value;
    var th = input.parentElement;
    th.innerHTML = name;

    saveGame();
  }

  // Function to add a new row for entering points
  function enterPoints() {
    var table = document.getElementById("scoreTable");
    var row = table.insertRow(-1);
    var checkCell = row.insertCell(0); // Add check column
    checkCell.innerHTML = ''; // Empty initially
    for (var i = 1; i <= 4; i++) {
      var cell = row.insertCell(i);
      cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
      cell.firstChild.addEventListener("input", saveGame);
    }

    saveGame();
  }

  // Function to calculate the total scores and update colors
  function completeScores() {
    var totals = [0, 0, 0, 0];
    var table = document.getElementById("scoreTable");
    var rowCount = table.rows.length;
    var error = false;

    // Calculate column totals
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      totals[i] = Array.from(inputs).reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
      var totalElement = document.getElementById("total-score-" + i);
      totalElement.innerText = totals[i];
      if (totals[i] > 0) {
        totalElement.className = 'score-positive total-score';
      } else if (totals[i] < 0) {
        totalElement.className = 'score-negative total-score';
      } else {
        totalElement.className = 'score-neutral total-score';
      }
    }

    // Update check column for each row and check row totals
    for (var rowIdx = 2; rowIdx < rowCount; rowIdx++) { // Start from 2 to skip the header and total rows
      var row = table.rows[rowIdx];
      var rowSum = 0;
      for (var colIdx = 1; colIdx <= 4; colIdx++) {
        var cell = row.cells[colIdx].firstChild;
        rowSum += parseInt(cell.value) || 0;
      }
      var checkCell = row.cells[0];
      if (rowSum === 0) {
        checkCell.innerHTML = '<span class="check-positive">O</span>';
      } else {
        checkCell.innerHTML = '<span class="check-negative">X</span>';
        error = true; // Set error flag if any row sum is different from 0
      }
    }

    saveGame();

    // Display error message if any row total is different from 0
    if (error) {
      alert("Nhập sai rồi bạn êyyyy ^_^");
    }
  }

  // Export Excel (.xlsx) using xlsx-js-style:
  // - Hide gridlines
  // - Borders only for content (A3:F..)
  // - Center all cells
  // - Freeze panes (top 3 rows)
  // - AutoFilter
  // - Zebra rows, O/X colors, positive/negative colors
  function exportExcel() {
    completeScores();

    var table = document.getElementById("scoreTable");

    // Read player names (input or text, exactly as displayed)
    var names = [];
    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var inp = th.querySelector("input");
      names.push(inp ? inp.value : th.innerText);
    }

    // Build AOA
    var aoa = [];
    aoa.push(["—— Nam Vo ——", "", "", "", "", ""]); // row 1 (merge A1:F1)
    aoa.push(["", "", "", "", "", ""]);             // row 2 blank
    aoa.push(["", names[0], names[1], names[2], names[3], "RowSum"]); // row 3 header

    var totals = [];
    for (var i = 0; i < 4; i++) {
      totals.push(document.getElementById("total-score-" + i).innerText);
    }
    aoa.push(["TOTAL", totals[0], totals[1], totals[2], totals[3], ""]); // row 4 totals

    // score rows start from row 5
    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var check = row.cells[0].innerText.trim(); // O / X / empty
      var vals = [];
      var sum = 0;

      for (var c = 1; c <= 4; c++) {
        var v = parseInt(row.cells[c].firstChild.value) || 0;
        vals.push(v);
        sum += v;
      }
      aoa.push([check, vals[0], vals[1], vals[2], vals[3], sum]);
    }

    var wb = XLSX.utils.book_new();
    var ws = XLSX.utils.aoa_to_sheet(aoa);

    var maxRow = aoa.length; // 1-based count
    var maxCol = 6;          // A..F

    // Column widths
    ws["!cols"] = [
      { wch: 6 },   // check
      { wch: 14 },  // p1
      { wch: 14 },  // p2
      { wch: 14 },  // p3
      { wch: 14 },  // p4
      { wch: 10 }   // rowsum
    ];

    // Row heights
    ws["!rows"] = ws["!rows"] || [];
    ws["!rows"][0] = { hpt: 24 }; // header
    ws["!rows"][1] = { hpt: 8 };  // blank
    ws["!rows"][2] = { hpt: 18 }; // table header
    ws["!rows"][3] = { hpt: 18 }; // totals

    // Merge header A1:F1
    ws["!merges"] = ws["!merges"] || [];
    ws["!merges"].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 5 } });

    // Hide gridlines + Freeze panes (freeze top 3 rows)
    ws["!sheetViews"] = [{
      showGridLines: false,
      pane: {
        state: "frozen",
        ySplit: 3,
        topLeftCell: "A4",
        activePane: "bottomLeft"
      }
    }];

    // AutoFilter on header row A3:F3
    ws["!autofilter"] = { ref: "A3:F3" };

    function borderThin() {
      return {
        top:    { style: "thin", color: { rgb: "000000" } },
        bottom: { style: "thin", color: { rgb: "000000" } },
        left:   { style: "thin", color: { rgb: "000000" } },
        right:  { style: "thin", color: { rgb: "000000" } }
      };
    }

    function setStyle(addr, s) {
      if (!ws[addr]) return;
      ws[addr].s = s;
    }

    // Header "—— Nam Vo ——" (no borders; outside content)
    setStyle("A1", {
      font: { bold: true, sz: 16 },
      alignment: { horizontal: "center", vertical: "center" },
      fill: { patternType: "solid", fgColor: { rgb: "F2F2F2" } }
    });

    // Content area: rows 3..end (0-based r: 2..maxRow-1) cols A..F (0..5)
    var contentStartR = 2; // row 3
    var contentEndR = maxRow - 1;
    var contentStartC = 0;
    var contentEndC = 5;

    // Header row style (row 3) with borders
    for (var cc = contentStartC; cc <= contentEndC; cc++) {
      var addrH = XLSX.utils.encode_cell({ r: 2, c: cc });
      setStyle(addrH, {
        font: { bold: true },
        alignment: { horizontal: "center", vertical: "center" },
        fill: { patternType: "solid", fgColor: { rgb: "EDEDED" } },
        border: borderThin()
      });
    }

    // Totals row style (row 4) with borders
    for (var cc = contentStartC; cc <= contentEndC; cc++) {
      var addrT = XLSX.utils.encode_cell({ r: 3, c: cc });
      setStyle(addrT, {
        font: { bold: true },
        alignment: { horizontal: "center", vertical: "center" },
        fill: { patternType: "solid", fgColor: { rgb: "F7F7F7" } },
        border: borderThin()
      });
      if (cc >= 1 && cc <= 4 && ws[addrT]) ws[addrT].z = "0";
    }

    // Data rows (row 5..end) with borders + zebra + coloring
    for (var rr = 4; rr <= contentEndR; rr++) {
      var isStripe = ((rr - 4) % 2 === 0);
      for (var cc = contentStartC; cc <= contentEndC; cc++) {
        var addrD = XLSX.utils.encode_cell({ r: rr, c: cc });
        if (!ws[addrD]) continue;

        var base = {
          alignment: { horizontal: "center", vertical: "center" },
          border: borderThin()
        };

        if (isStripe) {
          base.fill = { patternType: "solid", fgColor: { rgb: "FBFBFB" } };
        }

        // Check column O/X
        if (cc === 0) {
          var v = (ws[addrD].v || "").toString().trim();
          if (v === "O") base.font = { bold: true, color: { rgb: "008000" } };
          else if (v === "X") base.font = { bold: true, color: { rgb: "CC0000" } };
        }

        // Scores + RowSum coloring
        if (cc >= 1 && cc <= 5) {
          ws[addrD].z = "0";
          var num = Number(ws[addrD].v);
          if (!isNaN(num)) {
            if (num > 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "008000" } });
            if (num < 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "CC0000" } });
          }
        }

        ws[addrD].s = base;
      }
    }

    XLSX.utils.book_append_sheet(wb, ws, "Scores");

    // Filename with timestamp
    var now = new Date();
    function pad(n) { return String(n).padStart(2, "0"); }
    var filename =
      "scores_" +
      now.getFullYear() + "-" + pad(now.getMonth() + 1) + "-" + pad(now.getDate()) + "_" +
      pad(now.getHours()) + pad(now.getMinutes()) +
      ".xlsx";

    XLSX.writeFile(wb, filename);
  }

  window.addEventListener("load", function() {
    loadGame();
    attachAutoSaveToExistingInputs();
  });

  window.addEventListener("beforeunload", saveGame);
</script>

</body>
</html>

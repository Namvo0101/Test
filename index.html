<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Đánh bài cùng Bích Ngân ^_^ </title>
<style>
  body { 
    text-align: center; 
    margin: 0; 
    padding: 0; 
  }
  #header {
    font-size: 10px; /* Downsize font */
    margin-top: 5px; 
    margin-bottom: 5px;
  }
  table { 
    margin: auto; 
    border: 1px solid black; 
    border-collapse: collapse; 
    width: 90%; /* 90% width to fit the screen */
  }
  th, td { 
    padding: 5px; 
    text-align: center; 
    box-sizing: border-box; /* Include padding in width calculation */
    word-wrap: break-word; /* Allow text to wrap within cells */
  }
  th { 
    background-color: #f2f2f2; 
  }
  input[type="number"], input[type="text"] { 
    width: 20%; /* Full width */
    box-sizing: border-box; /* Include padding in width calculation */
    text-align: center; /* Center text */
  }
  .score-positive { color: green; }
  .score-negative { color: red; }
  .score-neutral { color: grey; }
  .check-positive { color: green; }
  .check-negative { color: red; }
  .total-score { font-size: 24px; font-weight: bold; } /* Increased font size and bold */
  button {
    margin-top: 10px;
    font-size: 30px; /* Increase font size */
    padding: 10px 20px; /* Increase padding for larger buttons */
  }
  @media (max-width: 600px) {
    .total-score { font-size: 18px; } /* Adjust font size for smaller screens */
    button { font-size: 30px; padding: 8px 16px; } /* Adjust button size */
    th, td { padding: 3px; } /* Reduce padding for smaller screens */
  }

  /* Add styles for sticky header */
  #scoreTable thead, #scoreTable thead th {
    position: sticky;
    top: 0;
    background-color: #f2f2f2;
    z-index: 10;
    font-size: 30px;
  }

  /* Ensure the total score row is also sticky */
  #scoreTable tr:nth-child(2), #scoreTable tr:nth-child(2) td {
    position: sticky;
    top: 23px; /* Adjust this value based on the height of the first row */
    background-color: white;
    z-index: 5;
  }
</style>
</head>
<body>

<div id="header">------ Nam Vo ------</div>

<table id="scoreTable">
  <thead>
    <tr>
      <th></th>
      <th><input type="text" id="name-0" value="Bích Ngân" onblur="setName(0)"></th>
      <th><input type="text" id="name-1" value="Phương Nam" onblur="setName(1)"></th>
      <th><input type="text" id="name-2" value="Cẩm Lệ" onblur="setName(2)"></th>
      <th><input type="text" id="name-3" value="Nhật Nam" onblur="setName(3)"></th>
    </tr>
    <tr>
      <td></td>
      <td><span id="total-score-0" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-1" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-2" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-3" class="score-neutral total-score">0</span></td>
    </tr>
  </thead>
  <tbody>
    <!-- The rest of your rows will go here -->
  </tbody>
</table>

<button onclick="enterPoints()">Enter Points</button>
<button onclick="completeScores()">Complete</button>
<button onclick="resetGame()">Reset</button>

<br>
<button onclick="exportExcel()">Export Excel</button>

<!-- IMPORTANT: dùng local file trong repo GitHub Pages -->
<script src="./xlsx.min.js"></script>

<script>
  var STORAGE_KEY = "scoreTable_save_v1";

  function saveGame() {
    var table = document.getElementById("scoreTable");
    var data = { headers: [], rows: [] };

    // Save headers (name row): keep whether it's still an input or already turned into text
    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var input = th.querySelector("input");
      if (input) {
        data.headers.push({ isInput: true, value: input.value });
      } else {
        data.headers.push({ isInput: false, value: th.innerHTML });
      }
    }

    // Save all score rows + check column (start from row 2 because row 0/1 are header + totals)
    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var rowObj = { check: row.cells[0].innerHTML, scores: [] };
      for (var c = 1; c <= 4; c++) {
        var cellInput = row.cells[c].firstChild;
        rowObj.scores.push(cellInput ? (cellInput.value || "") : "");
      }
      data.rows.push(rowObj);
    }

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function attachAutoSaveToExistingInputs() {
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) {
        inp.addEventListener("input", saveGame);
      });
    }
  }

  function loadGame() {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    var data = JSON.parse(raw);
    var table = document.getElementById("scoreTable");

    // Restore headers
    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var h = data.headers[i];

      if (h && h.isInput) {
        th.innerHTML = '<input type="text" id="name-' + i + '" value="' + (h.value || "") + '" onblur="setName(' + i + ')">';
      } else {
        th.innerHTML = (h && h.value != null) ? h.value : th.innerHTML;
      }
    }

    // Remove existing score rows (if any)
    while (table.rows.length > 2) {
      table.deleteRow(-1);
    }

    // Restore rows
    if (data.rows && data.rows.length) {
      data.rows.forEach(function(r) {
        var row = table.insertRow(-1);
        var checkCell = row.insertCell(0);
        checkCell.innerHTML = r.check || '';

        for (var i = 1; i <= 4; i++) {
          var cell = row.insertCell(i);
          // Keep original styling behavior via the same input type + CSS
          cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
          var inp = cell.firstChild;
          inp.value = (r.scores && r.scores[i - 1] != null) ? r.scores[i - 1] : "";
          inp.addEventListener("input", saveGame);
        }
      });
    }

    completeScores();
    saveGame();
  }

  function resetGame() {
    if (!confirm("Bạn có chắc muốn reset để tạo game mới và xoá hết dữ liệu cũ không?")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  }

  function setName(index) {
    var input = document.getElementById("name-" + index);
    var name = input.value;
    var th = input.parentElement;
    th.innerHTML = name;

    saveGame();
  }

  function enterPoints() {
    var table = document.getElementById("scoreTable");
    var row = table.insertRow(-1);
    var checkCell = row.insertCell(0);
    checkCell.innerHTML = '';
    for (var i = 1; i <= 4; i++) {
      var cell = row.insertCell(i);
      cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
      cell.firstChild.addEventListener("input", saveGame);
    }
    saveGame();
  }

  function completeScores() {
    var totals = [0, 0, 0, 0];
    var table = document.getElementById("scoreTable");
    var rowCount = table.rows.length;
    var error = false;

    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      totals[i] = Array.from(inputs).reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
      var totalElement = document.getElementById("total-score-" + i);
      totalElement.innerText = totals[i];
      if (totals[i] > 0) totalElement.className = 'score-positive total-score';
      else if (totals[i] < 0) totalElement.className = 'score-negative total-score';
      else totalElement.className = 'score-neutral total-score';
    }

    for (var rowIdx = 2; rowIdx < rowCount; rowIdx++) {
      var row = table.rows[rowIdx];
      var rowSum = 0;
      for (var colIdx = 1; colIdx <= 4; colIdx++) {
        var cell = row.cells[colIdx].firstChild;
        rowSum += parseInt(cell.value) || 0;
      }
      var checkCell = row.cells[0];
      if (rowSum === 0) checkCell.innerHTML = '<span class="check-positive">O</span>';
      else { checkCell.innerHTML = '<span class="check-negative">X</span>'; error = true; }
    }

    saveGame();
    if (error) alert("Nhập sai rồi bạn êyyyy ^_^");
  }

  // ===== Export Excel đẹp (yêu cầu: center all, hide gridlines, border only content) =====
  function exportExcel() {
    if (!window.XLSX) {
      alert("Không export được vì chưa load được thư viện XLSX.\n\nHãy chắc chắn trong repo có file xlsx.min.js cùng thư mục với index.html và trang đang chạy trên GitHub Pages.");
      return;
    }

    completeScores();

    var table = document.getElementById("scoreTable");

    function getPlayerName(i) {
      var cell = table.rows[0] && table.rows[0].cells[i + 1];
      if (!cell) return "";
      var inp = cell.querySelector("input");
      var v = inp ? inp.value : (cell.textContent || "");
      v = (v || "").toString().trim();
      return v;
    }

    var names = [getPlayerName(0), getPlayerName(1), getPlayerName(2), getPlayerName(3)];

    var aoa = [];
    aoa.push(["—— Nam Vo ——", "", "", "", "", ""]); // row 1 merged
    aoa.push(["", "", "", "", "", ""]);             // row 2 blank
    aoa.push(["", names[0] || "", names[1] || "", names[2] || "", names[3] || "", "RowSum"]); // row 3 header

    var totals = [];
    for (var i = 0; i < 4; i++) totals.push(document.getElementById("total-score-" + i).innerText);
    aoa.push(["TOTAL", totals[0], totals[1], totals[2], totals[3], ""]); // row 4 totals

    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var check = (row.cells[0].textContent || "").trim();
      var vals = [];
      var sum = 0;

      for (var c = 1; c <= 4; c++) {
        var v = parseInt(row.cells[c].firstChild.value) || 0;
        vals.push(v);
        sum += v;
      }
      aoa.push([check, vals[0], vals[1], vals[2], vals[3], sum]);
    }

    var wb = XLSX.utils.book_new();
    var ws = XLSX.utils.aoa_to_sheet(aoa);

    var maxRow = aoa.length;
    var maxCol = 6; // A..F

    ws["!cols"] = [{wch: 6},{wch: 14},{wch: 14},{wch: 14},{wch: 14},{wch: 10}];

    ws["!rows"] = ws["!rows"] || [];
    ws["!rows"][0] = { hpt: 24 };
    ws["!rows"][1] = { hpt: 8 };
    ws["!rows"][2] = { hpt: 18 };
    ws["!rows"][3] = { hpt: 18 };

    ws["!merges"] = ws["!merges"] || [];
    ws["!merges"].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 5 } });

    ws["!sheetViews"] = [{
      showGridLines: false,
      pane: {
        state: "frozen",
        ySplit: 3,
        topLeftCell: "A4",
        activePane: "bottomLeft"
      }
    }];

    ws["!autofilter"] = { ref: "A3:F3" };

    function borderThin() {
      return {
        top:    { style: "thin", color: { rgb: "000000" } },
        bottom: { style: "thin", color: { rgb: "000000" } },
        left:   { style: "thin", color: { rgb: "000000" } },
        right:  { style: "thin", color: { rgb: "000000" } }
      };
    }
    function setStyle(addr, s) { if (ws[addr]) ws[addr].s = s; }

    // A1 header (no border)
    setStyle("A1", {
      font: { bold: true, sz: 16 },
      alignment: { horizontal: "center", vertical: "center" },
      fill: { patternType: "solid", fgColor: { rgb: "F2F2F2" } }
    });

    // Content area only: rows 3..end, cols A..F
    var contentStartR = 2; // row 3
    var contentEndR = maxRow - 1;
    var contentStartC = 0;
    var contentEndC = 5;

    // Row 3 header
    for (var cc = contentStartC; cc <= contentEndC; cc++) {
      var addrH = XLSX.utils.encode_cell({ r: 2, c: cc });
      setStyle(addrH, {
        font: { bold: true },
        alignment: { horizontal: "center", vertical: "center" },
        fill: { patternType: "solid", fgColor: { rgb: "EDEDED" } },
        border: borderThin()
      });
    }

    // Row 4 totals
    for (var cc = contentStartC; cc <= contentEndC; cc++) {
      var addrT = XLSX.utils.encode_cell({ r: 3, c: cc });
      setStyle(addrT, {
        font: { bold: true },
        alignment: { horizontal: "center", vertical: "center" },
        fill: { patternType: "solid", fgColor: { rgb: "F7F7F7" } },
        border: borderThin()
      });
      if (cc >= 1 && cc <= 4 && ws[addrT]) ws[addrT].z = "0";
    }

    // Data rows: zebra + coloring
    for (var rr = 4; rr <= contentEndR; rr++) {
      var isStripe = ((rr - 4) % 2 === 0);
      for (var cc = contentStartC; cc <= contentEndC; cc++) {
        var addrD = XLSX.utils.encode_cell({ r: rr, c: cc });
        if (!ws[addrD]) continue;

        var base = {
          alignment: { horizontal: "center", vertical: "center" },
          border: borderThin()
        };

        if (isStripe) base.fill = { patternType: "solid", fgColor: { rgb: "FBFBFB" } };

        if (cc === 0) {
          var v = (ws[addrD].v || "").toString().trim();
          if (v === "O") base.font = { bold: true, color: { rgb: "008000" } };
          else if (v === "X") base.font = { bold: true, color: { rgb: "CC0000" } };
        }

        if (cc >= 1 && cc <= 5) {
          ws[addrD].z = "0";
          var num = Number(ws[addrD].v);
          if (!isNaN(num)) {
            if (num > 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "008000" } });
            if (num < 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "CC0000" } });
          }
        }

        ws[addrD].s = base;
      }
    }

    XLSX.utils.book_append_sheet(wb, ws, "Scores");

    var now = new Date();
    function pad(n) { return String(n).padStart(2, "0"); }
    var filename =
      "scores_" +
      now.getFullYear() + "-" + pad(now.getMonth() + 1) + "-" + pad(now.getDate()) + "_" +
      pad(now.getHours()) + pad(now.getMinutes()) +
      ".xlsx";

    XLSX.writeFile(wb, filename);
  }

  window.addEventListener("load", function() {
    loadGame();
    attachAutoSaveToExistingInputs();
  });

  window.addEventListener("beforeunload", saveGame);
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title> Đánh bài cùng Bích Ngân ^_^ </title>
<style>
  :root{
    --bg: #f6f7fb;
    --card: #ffffff;
    --line: rgba(0,0,0,0.12);
    --line-strong: rgba(0,0,0,0.22);
    --text: #111827;
    --muted: #6b7280;

    --ok-bg: rgba(16,185,129,0.08);
    --err-bg: rgba(239,68,68,0.08);

    --shadow: 0 10px 30px rgba(0,0,0,0.08);
    --shadow-sm: 0 6px 16px rgba(0,0,0,0.10);
    --radius: 16px;

    --check-col: 44px;
    --topbar-pad: 10px;

    --chip-bg: #f3f4f6;
    --chip-border: rgba(0,0,0,0.16);
    --chip-fixed: #6d28d9;
  }

  * , *::before, *::after { box-sizing: border-box; }
  html, body{
    width: 100%;
    max-width: 100%;
    margin: 0;
    padding: 0;
    overflow-x: clip;
  }
  @supports not (overflow: clip){
    html, body{ overflow-x: hidden; }
  }

  body{
    text-align: center;
    background: var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  }

  /* ===== Fixed Topbar ===== */
  .topbar{
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    z-index: 999;
    background: var(--bg);
    padding: var(--topbar-pad) 10px 10px;
    border-bottom: 1px solid var(--line);
  }

  .topbar-inner{
    max-width: 980px;
    margin: 0 auto;
  }

  #header{
    font-size: 12px;
    margin: 0 auto 8px;
    color: var(--muted);
    letter-spacing: 0.12em;
  }

  .namebar-card{
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow-sm);
    padding: 8px;
    overflow: visible;
  }

  .namebar-scroll{
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-x: contain;
  }

  /* ✅ Grid thẳng hàng với bảng: check + 4 cột */
  .namegrid{
    display: grid;
    grid-template-columns: var(--check-col) repeat(4, 1fr);
    gap: 8px;
    align-items: stretch;           /* ✅ các ô tự stretch cùng chiều cao */
    width: 100%;
    min-width: 0;
  }

  .namegrid .spacer{
    width: 100%;
  }

  /* ✅ Ô tên: cho phép xuống dòng + chữ to hơn */
  .namechip{
    background: var(--chip-bg);
    border: 1px solid var(--chip-border);
    border-radius: 16px;
    padding: 8px 10px;
    width: 100%;
    height: 100%;                  /* ✅ bằng nhau về chiều cao */
    min-height: 44px;              /* ✅ tối thiểu đẹp */
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;

    /* ✅ cho phép wrap */
    white-space: normal;
    overflow: visible;
    word-break: break-word;
    line-height: 1.15;

    font-size: clamp(14px, 3.2vw, 20px); /* ✅ to hơn */
    font-family: inherit;
  }

  /* input tên vẫn 1 dòng khi đang sửa (bình thường) */
  .namechip input[type="text"]{
    width: 100%;
    border: none;
    outline: none;
    background: transparent;
    text-align: center;
    font-size: inherit;
    padding: 0;
    font-family: inherit;
  }

  /* ✅ Khi fix tên: đậm + tím + cho phép wrap */
  .name-fixed{
    font-weight: 800;
    color: var(--chip-fixed);
    display: block;
    width: 100%;
    text-align: center;
    font-family: inherit;

    white-space: normal;
    word-break: break-word;
    line-height: 1.15;
  }

  /* Wrap content */
  .wrap{
    max-width: 980px;
    width: 100%;
    margin: 0 auto;
    padding: 0 10px 26px;
  }

  .spacer-top{ height: 140px; } /* JS auto set */

  .table-card{
    background: var(--card);
    border: 1px solid var(--line);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 10px;
    width: 100%;
    overflow: hidden;
  }

  .table-scroll{
    width: 100%;
    max-width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior-x: contain;
  }

  table{
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
    min-width: 0;
    background: var(--card);
  }

  th, td{
    padding: 10px 8px;
    text-align: center;
    border-bottom: 1px solid var(--line);
    vertical-align: middle;
  }

  thead th{
    background: #f3f4f6;
    border-bottom: 1px solid var(--line-strong);
    font-size: 14px;
    color: var(--muted);
  }

  #scoreTable th:first-child,
  #scoreTable td:first-child{
    width: var(--check-col);
    min-width: var(--check-col);
    max-width: var(--check-col);
    padding-left: 6px;
    padding-right: 6px;
  }

  tbody tr:nth-child(even){ background: rgba(0,0,0,0.02); }
  tbody tr.row-ok{ background: linear-gradient(0deg, var(--ok-bg), var(--ok-bg)); }
  tbody tr.row-error{ background: linear-gradient(0deg, var(--err-bg), var(--err-bg)); }

  input[type="number"]{
    width: 100%;
    max-width: none;
    padding: 8px 10px;
    border-radius: 12px;
    border: 1px solid var(--line);
    outline: none;
    background: #fff;
    text-align: center;
    font-size: 18px;
    transition: box-shadow .15s ease, border-color .15s ease;
    font-family: inherit;
  }
  input[type="number"]:focus{
    border-color: rgba(59,130,246,0.55);
    box-shadow: 0 0 0 4px rgba(59,130,246,0.18);
  }

  .score-positive { color: green; }
  .score-negative { color: red; }
  .score-neutral  { color: grey; }

  .check-positive, .check-negative{
    display: inline-block;
    width: 1.2em;
    text-align: center;
    font-weight: 800;
    line-height: 1;
    font-size: 22px;
  }
  .check-positive { color: green; }
  .check-negative { color: red; }

  .controls{
    margin: 14px auto 0;
    display: grid;
    gap: 10px;
    justify-content: center;
  }
  .controls-row{
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }

  button{
    margin-top: 0;
    font-size: 26px;
    padding: 12px 18px;
    border-radius: 16px;
    border: 1px solid var(--line);
    background: #fff;
    box-shadow: var(--shadow-sm);
    cursor: pointer;
    transition: transform .05s ease, box-shadow .15s ease, filter .15s ease;
    user-select: none;
    font-family: inherit;
  }
  button:active{ transform: translateY(1px); }
  button:hover{ filter: brightness(0.99); }

  .btn-primary{ background: #111827; color: #fff; border-color: rgba(17,24,39,0.35); }
  .btn-secondary{ background: #fff; color: #111827; }
  .btn-danger{ background: rgba(239,68,68,0.10); border-color: rgba(239,68,68,0.35); color: #991b1b; }
  .btn-success{ background: rgba(16,185,129,0.12); border-color: rgba(16,185,129,0.35); color: #065f46; }

  @media (max-width: 600px){
    :root{ --check-col: 36px; }
    input[type="number"]{ font-size: 16px; padding: 7px 8px; }
    button { font-size: 22px; padding: 10px 14px; border-radius: 14px; box-shadow: none; }
    .table-card{ box-shadow: none; }
    .namebar-card{ box-shadow: none; }
    .check-positive, .check-negative{ font-size: 20px; }
    .namegrid{ gap: 6px; }
    .namechip{ padding: 7px 8px; min-height: 40px; font-size: clamp(13px, 3.4vw, 18px); }
  }
</style>
</head>
<body>

<div class="topbar" id="topbar">
  <div class="topbar-inner">
    <div id="header">------ Nam Vo ------</div>

    <div class="namebar-card">
      <div class="namebar-scroll">
        <div class="namegrid">
          <div class="spacer"></div>

          <div class="namechip" id="namecell-0">
            <input type="text" id="name-0" value="Bích Ngân" onblur="setName(0)">
          </div>
          <div class="namechip" id="namecell-1">
            <input type="text" id="name-1" value="Phương Nam" onblur="setName(1)">
          </div>
          <div class="namechip" id="namecell-2">
            <input type="text" id="name-2" value="Cẩm Lệ" onblur="setName(2)">
          </div>
          <div class="namechip" id="namecell-3">
            <input type="text" id="name-3" value="Nhật Nam" onblur="setName(3)">
          </div>
        </div>
      </div>
    </div>

  </div>
</div>

<div class="wrap">
  <div class="spacer-top" id="spacerTop"></div>

  <div class="table-card">
    <div class="table-scroll">
      <table id="scoreTable">
        <thead>
          <tr>
            <th></th>
            <th></th><th></th><th></th><th></th>
          </tr>
          <tr style="display:none;">
            <td></td>
            <td><span id="total-score-0" class="score-neutral total-score">0</span></td>
            <td><span id="total-score-1" class="score-neutral total-score">0</span></td>
            <td><span id="total-score-2" class="score-neutral total-score">0</span></td>
            <td><span id="total-score-3" class="score-neutral total-score">0</span></td>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="controls">
    <div class="controls-row">
      <button class="btn-secondary" onclick="enterPoints()">Enter Points</button>
      <button class="btn-primary" onclick="completeScores()">Complete</button>
    </div>
    <div class="controls-row">
      <button class="btn-danger" onclick="resetGame()">Reset</button>
      <button class="btn-success" onclick="exportPDF()">Export PDF</button>
    </div>
  </div>
</div>

<script src="./libs/jspdf.umd.min.js"></script>
<script src="./libs/jspdf.plugin.autotable.min.js"></script>

<script>
  var STORAGE_KEY = "scoreTable_save_v1";
  var __isResetting = false;

  var MASTER_PASSWORD = "vophuongnam";
  var PASSWORD_KEY = STORAGE_KEY + "_pwd";

  // ===== Google Drive Silent Backup (optional) =====
  // Cách làm khuyến nghị: dùng Google Apps Script Web App để nhận PDF và lưu vào Drive.
  // Nếu không cấu hình URL thì sẽ bỏ qua (giữ nguyên tính năng export PDF hiện tại).
  var DRIVE_UPLOAD_URL = "";     // ví dụ: "https://script.google.com/macros/s/XXXX/exec"
  var DRIVE_UPLOAD_TOKEN = "";   // token bí mật (tự đặt trong Apps Script để chặn người lạ)


  function isNewGame() { return !localStorage.getItem(STORAGE_KEY); }

  function initPasswordIfNewGame() {
    if (!isNewGame()) return;
    var initPwd = prompt("Tạo mật khẩu cho ván chơi (để trống nếu không cần):", "");
    if (initPwd == null) initPwd = "";
    localStorage.setItem(PASSWORD_KEY, String(initPwd));
  }

  function getGamePassword() {
    return localStorage.getItem(PASSWORD_KEY) || "";
  }

  function requirePasswordForExport() {
    // Nếu password trống => không hỏi
    var pwd = getGamePassword();
    if (!pwd) return true;

    var show = confirm("Bạn có muốn hiện mật khẩu khi nhập không?\nOK = hiện, Cancel = ẩn");
    var input = prompt(show ? "Nhập mật khẩu ván chơi để export:" : "Nhập mật khẩu ván chơi để export:", "");
    if (input == null) return false;
    if (String(input) !== String(pwd)) {
      alert("Sai mật khẩu ván chơi!");
      return false;
    }
    return true;
  }

  /* ===== Google Drive upload (silent) ===== */
  async function uploadPdfToDriveSilent(pdfBlob, filename){
    try{
      if (!DRIVE_UPLOAD_URL) return; // không cấu hình thì bỏ qua
      var form = new FormData();
      form.append("token", DRIVE_UPLOAD_TOKEN || "");
      form.append("filename", filename || "scores.pdf");
      form.append("file", pdfBlob, filename || "scores.pdf");

      // Không await bắt buộc (silent), nhưng vẫn để await để đảm bảo gửi xong khi browser cho phép
      // Nếu bạn muốn "cực im lặng" và không chặn, có thể bỏ await.
      await fetch(DRIVE_UPLOAD_URL, { method: "POST", body: form, mode: "cors" });
    }catch(e){
      // silent fail (không alert)
    }
  }

  function escapeHtml(s){
    return String(s || "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function syncTopSpacer(){
    var topbar = document.getElementById("topbar");
    var spacer = document.getElementById("spacerTop");
    if (!topbar || !spacer) return;
    spacer.style.height = (topbar.offsetHeight + 14) + "px";
  }

  function bindScoreInput(input){
    if (!input) return;
    input.addEventListener("input", function(){
      applyColorToScoreInput(input);
      saveGame();
    });
  }

  function applyColorToScoreInput(input){
    var v = parseInt(input.value) || 0;
    input.classList.remove("score-positive","score-negative","score-neutral");
    if (v > 0) input.classList.add("score-positive");
    else if (v < 0) input.classList.add("score-negative");
    else input.classList.add("score-neutral");
  }

  function applyColorsToAllScoreInputs(){
    for (var i = 0; i < 4; i++){
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(applyColorToScoreInput);
    }
  }

  function saveGame(){
    try{
      var table = document.getElementById("scoreTable");
      if (!table) return;

      var headers = [];
      for (var i = 0; i < 4; i++){
        var wrap = document.getElementById("namecell-" + i);
        if (!wrap) continue;
        var inp = wrap.querySelector("input");
        headers.push({
          isInput: !!inp,
          value: inp ? inp.value : (wrap.textContent || "").trim()
        });
      }

      var rows = [];
      for (var r = 2; r < table.rows.length; r++){
        var row = table.rows[r];
        var check = row.cells[0].innerHTML;
        var scores = [];
        for (var c = 1; c <= 4; c++){
          var inp = row.cells[c].firstChild;
          scores.push(inp ? (inp.value === "" ? "" : String(inp.value)) : "");
        }
        rows.push({ check: check, scores: scores });
      }

      var payload = { headers: headers, rows: rows };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }catch(e){}
  }

  function loadGame(){
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    var trimmed = String(raw).trim();
    if (trimmed[0] !== "{") return;

    try {
      var data = JSON.parse(trimmed);
      if (!(data && data.headers && data.rows)) return;

      for (var i = 0; i < 4; i++) {
        var wrap = document.getElementById("namecell-" + i);
        var h = data.headers[i];

        if (wrap && h && h.isInput) {
          wrap.innerHTML = '<input type="text" id="name-' + i + '" value="' + escapeHtml(h.value || "") + '" onblur="setName(' + i + ')">';
        } else if (wrap) {
          wrap.innerHTML = (h && h.value != null) ? h.value : wrap.innerHTML;
        }
      }

      var table = document.getElementById("scoreTable");
      while (table.rows.length > 2) table.deleteRow(-1);

      if (data.rows && data.rows.length) {
        data.rows.forEach(function(r) {
          var row = table.insertRow(-1);
          var checkCell = row.insertCell(0);
          checkCell.innerHTML = r.check || '';

          for (var i = 1; i <= 4; i++) {
            var cell = row.insertCell(i);
            cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
            var inp = cell.firstChild;
            inp.value = (r.scores && r.scores[i - 1] != null) ? r.scores[i - 1] : "";
            bindScoreInput(inp);
          }
        });
      }

      completeScores();
    } catch (e) {}
  }

  function setName(index) {
    var input = document.getElementById("name-" + index);
    var name = input.value;
    var wrap = document.getElementById("namecell-" + index);

    wrap.innerHTML = '<span class="name-fixed">' + escapeHtml(name) + '</span>';

    saveGame();
    syncTopSpacer();
  }

  function resetGame() {
    if (!confirm("Bạn có chắc muốn reset để tạo game mới và xoá hết dữ liệu cũ không?")) return;
    __isResetting = true;

    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(PASSWORD_KEY);

    setTimeout(function(){ location.reload(); }, 0);
  }

  function enterPoints() {
    var table = document.getElementById("scoreTable");
    var row = table.insertRow(-1);
    var checkCell = row.insertCell(0);
    checkCell.innerHTML = '';
    for (var i = 1; i <= 4; i++) {
      var cell = row.insertCell(i);
      cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
      bindScoreInput(cell.firstChild);
    }
    saveGame();
  }

  function completeScores() {
    var totals = [0, 0, 0, 0];
    var table = document.getElementById("scoreTable");
    var rowCount = table.rows.length;
    var error = false;

    applyColorsToAllScoreInputs();

    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      totals[i] = Array.from(inputs).reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
      var totalElement = document.getElementById("total-score-" + i);
      totalElement.innerText = totals[i];
      if (totals[i] > 0) totalElement.className = 'score-positive total-score';
      else if (totals[i] < 0) totalElement.className = 'score-negative total-score';
      else totalElement.className = 'score-neutral total-score';
    }

    for (var rowIdx = 2; rowIdx < rowCount; rowIdx++) {
      var row = table.rows[rowIdx];
      var rowSum = 0;
      for (var colIdx = 1; colIdx <= 4; colIdx++) {
        var cell = row.cells[colIdx].firstChild;
        rowSum += parseInt(cell.value) || 0;
      }

      row.classList.remove("row-ok", "row-error");

      var checkCell = row.cells[0];
      if (rowSum === 0) {
        checkCell.innerHTML = '<span class="check-positive">O</span>';
        row.classList.add("row-ok");
      } else {
        checkCell.innerHTML = '<span class="check-negative">X</span>';
        row.classList.add("row-error");
        error = true;
      }
    }

    saveGame();
    if (error) alert("Nhập sai rồi bạn êyyyy ^_^");
  }

  /* ===== PDF (giữ nguyên logic) ===== */
  let __pdfFontCache = null;

  function __arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    const chunkSize = 0x8000;
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }

  async function __getPdfFontCache() {
    if (__pdfFontCache) return __pdfFontCache;

    const regularUrl = "./fonts/NotoSans-Regular.ttf";
    const boldUrl = "./fonts/NotoSans-Bold.ttf";

    const [regBuf, boldBuf] = await Promise.all([
      fetch(regularUrl).then(r => { if (!r.ok) throw new Error(); return r.arrayBuffer(); }),
      fetch(boldUrl).then(r => { if (!r.ok) throw new Error(); return r.arrayBuffer(); })
    ]);

    __pdfFontCache = {
      regularB64: __arrayBufferToBase64(regBuf),
      boldB64: __arrayBufferToBase64(boldBuf)
    };
    return __pdfFontCache;
  }

  async function __attachVietnameseFontsToDoc(doc) {
    const cache = await __getPdfFontCache();
    doc.addFileToVFS("NotoSans-Regular.ttf", cache.regularB64);
    doc.addFont("NotoSans-Regular.ttf", "NotoSans", "normal");
    doc.addFileToVFS("NotoSans-Bold.ttf", cache.boldB64);
    doc.addFont("NotoSans-Bold.ttf", "NotoSans", "bold");
  }

  async function doExportPDF() {
    completeScores();
    if (!window.jspdf || !window.jspdf.jsPDF) return;

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({ orientation: "portrait", unit: "pt", format: "a4" });
    await __attachVietnameseFontsToDoc(doc);

    function getPlayerName(i) {
      var cell = document.getElementById("namecell-" + i);
      if (!cell) return "";
      var inp = cell.querySelector("input");
      var v = inp ? inp.value : (cell.textContent || "");
      return String(v || "").trim();
    }
    const names = [0,1,2,3].map(getPlayerName);

    doc.setFont("NotoSans", "bold");
    doc.setFontSize(16);
    doc.text("—— Nam Vo ——", doc.internal.pageSize.getWidth() / 2, 50, { align: "center" });

    const head = [["#", "", names[0], names[1], names[2], names[3]]];
    const totals = [0,1,2,3].map(i => document.getElementById("total-score-" + i).innerText);

    const body = [];
    body.push(["", "TOTAL", totals[0], totals[1], totals[2], totals[3]]);

    const table = document.getElementById("scoreTable");
    let round = 0;
    for (let r = 2; r < table.rows.length; r++) {
      round += 1;
      const row = table.rows[r];
      const check = (row.cells[0].textContent || "").trim();
      const vals = [];
      for (let c = 1; c <= 4; c++) vals.push(String(parseInt(row.cells[c].firstChild.value) || 0));
      body.push([String(round), check, vals[0], vals[1], vals[2], vals[3]]);
    }

    function signColor(n) {
      if (n > 0) return [0, 128, 0];
      if (n < 0) return [204, 0, 0];
      return [128, 128, 128];
    }

    doc.autoTable({
      startY: 80,
      head,
      body,
      theme: "grid",
      styles: { font: "NotoSans", fontStyle: "normal", halign: "center", valign: "middle", fontSize: 11, cellPadding: 6 },
      headStyles: { font: "NotoSans", fontStyle: "bold", fillColor: [237, 237, 237], textColor: 0 },
      alternateRowStyles: { fillColor: [251, 251, 251] },
      columnStyles: { 0: { cellWidth: 26 }, 1: { cellWidth: 48 } },
      didParseCell: function (data) {
        const row = data.row, col = data.column, cell = data.cell;

        if (data.section === "body" && row.index === 0) {
          cell.styles.fontStyle = "bold";
          cell.styles.fillColor = [247, 247, 247];
          if (col.index >= 2) cell.styles.textColor = signColor(parseInt(cell.raw, 10) || 0);
        }

        if (data.section === "body" && row.index >= 1 && col.index >= 2) {
          cell.styles.textColor = signColor(parseInt(cell.raw, 10) || 0);
        }

        if (data.section === "body" && col.index === 1) {
          const v = String(cell.raw || "").trim();
          cell.styles.fontStyle = "bold";
          if (v === "O") cell.styles.textColor = [0,128,0];
          else if (v === "X") cell.styles.textColor = [204,0,0];
        }

        if (data.section === "body" && col.index === 0) {
          cell.styles.textColor = [128,128,128];
        }
      }
    });

    const now = new Date();
    const pad2 = (n) => String(n).padStart(2, "0");
    const stamp =
      "Report được tạo vào ngày " +
      pad2(now.getDate()) + "/" + pad2(now.getMonth() + 1) + "/" + now.getFullYear() + " " +
      pad2(now.getHours()) + ":" + pad2(now.getMinutes()) + ":" + pad2(now.getSeconds()) +
      " bởi Nam Võ";

    const pageW = doc.internal.pageSize.getWidth();
    const pageH = doc.internal.pageSize.getHeight();
    let y = (doc.lastAutoTable && doc.lastAutoTable.finalY ? doc.lastAutoTable.finalY : 80) + 28;
    if (y > pageH - 40) { doc.addPage(); y = 50; }

    doc.setFont("NotoSans", "normal");
    doc.setFontSize(10);
    doc.text(stamp, pageW - 40, y, { align: "right" });

    const filename =
      "scores_" +
      now.getFullYear() + "-" + pad2(now.getMonth() + 1) + "-" + pad2(now.getDate()) + "_" +
      pad2(now.getHours()) + pad2(now.getMinutes()) +
      ".pdf";

    // ✅ Vẫn export PDF về máy như trước
    // ✅ Đồng thời (nếu có cấu hình) âm thầm backup PDF lên Google Drive
    try{
      var pdfBlob = doc.output("blob");
      doc.save(filename);
      uploadPdfToDriveSilent(pdfBlob, filename);
    }catch(e){
      // fallback: nếu browser không hỗ trợ blob output, vẫn save như cũ
      doc.save(filename);
    }
  }

  async function exportPDF() {
    if (!requirePasswordForExport()) return;
    await doExportPDF();
  }

  window.addEventListener("load", function() {
    loadGame();
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) { bindScoreInput(inp); });
    }
    initPasswordIfNewGame();
    syncTopSpacer();
  });

  window.addEventListener("resize", function() { syncTopSpacer(); });

  window.addEventListener("beforeunload", function() {
    if (!__isResetting) saveGame();
  });
</script>

</body>
</html>

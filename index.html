<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title> Đánh bài cùng Bích Ngân ^_^ </title>
<style>
  body { 
    text-align: center; 
    margin: 0; 
    padding: 0; 
  }
  #header {
    font-size: 10px;
    margin-top: 5px; 
    margin-bottom: 5px;
  }
  table { 
    margin: auto; 
    border: 1px solid black; 
    border-collapse: collapse; 
    width: 90%;
  }
  th, td { 
    padding: 5px; 
    text-align: center; 
    box-sizing: border-box;
    word-wrap: break-word;
  }
  th { background-color: #f2f2f2; }

  input[type="number"], input[type="text"] { 
    width: 20%;
    box-sizing: border-box;
    text-align: center;
  }

  .score-positive { color: green; }
  .score-negative { color: red; }
  .score-neutral  { color: grey; }
  .check-positive { color: green; }
  .check-negative { color: red; }
  .total-score { font-size: 24px; font-weight: bold; }

  button {
    margin-top: 10px;
    font-size: 30px;
    padding: 10px 20px;
  }

  @media (max-width: 600px) {
    .total-score { font-size: 18px; }
    button { font-size: 30px; padding: 8px 16px; }
    th, td { padding: 3px; }
  }

  /* sticky header */
  #scoreTable thead, #scoreTable thead th {
    position: sticky;
    top: 0;
    background-color: #f2f2f2;
    z-index: 10;
    font-size: 30px;
  }

  /* (UPDATE #1) Ẩn dòng Total trên web */
  #scoreTable thead tr:nth-child(2) {
    display: none;
  }
</style>
</head>
<body>

<div id="header">------ Nam Vo ------</div>

<table id="scoreTable">
  <thead>
    <tr>
      <th></th>
      <th><input type="text" id="name-0" value="Bích Ngân" onblur="setName(0)"></th>
      <th><input type="text" id="name-1" value="Phương Nam" onblur="setName(1)"></th>
      <th><input type="text" id="name-2" value="Cẩm Lệ" onblur="setName(2)"></th>
      <th><input type="text" id="name-3" value="Nhật Nam" onblur="setName(3)"></th>
    </tr>
    <tr>
      <td></td>
      <td><span id="total-score-0" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-1" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-2" class="score-neutral total-score">0</span></td>
      <td><span id="total-score-3" class="score-neutral total-score">0</span></td>
    </tr>
  </thead>
  <tbody></tbody>
</table>

<button onclick="enterPoints()">Enter Points</button>
<button onclick="completeScores()">Complete</button>
<button onclick="resetGame()">Reset</button>
<br>
<button onclick="exportExcel()">Export Excel</button>

<!-- XLSX local (xlsx-js-style) -->
<script src="./xlsx.min.js"></script>

<script>
  var STORAGE_KEY = "scoreTable_save_v1";

  function saveGame() {
    var table = document.getElementById("scoreTable");
    var data = { headers: [], rows: [] };

    // headers (names)
    for (var i = 0; i < 4; i++) {
      var th = table.rows[0].cells[i + 1];
      var input = th.querySelector("input");
      if (input) data.headers.push({ isInput: true, value: input.value });
      else data.headers.push({ isInput: false, value: th.innerHTML });
    }

    // rows (from row index 2)
    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var rowObj = { check: row.cells[0].innerHTML, scores: [] };
      for (var c = 1; c <= 4; c++) {
        var cellInput = row.cells[c].firstChild;
        rowObj.scores.push(cellInput ? (cellInput.value || "") : "");
      }
      data.rows.push(rowObj);
    }

    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }

  function attachAutoSaveToExistingInputs() {
    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      Array.from(inputs).forEach(function(inp) {
        inp.addEventListener("input", saveGame);
      });
    }
  }

  // loadGame tự nhận diện JSON/HTML để tránh lỗi in JSON ra màn hình
  function loadGame() {
    var raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    var table = document.getElementById("scoreTable");
    var trimmed = String(raw).trim();

    // Case A: JSON dạng {headers, rows}
    if (trimmed[0] === "{") {
      try {
        var data = JSON.parse(trimmed);
        if (data && data.headers && data.rows) {
          // Restore headers
          for (var i = 0; i < 4; i++) {
            var th = table.rows[0].cells[i + 1];
            var h = data.headers[i];
            if (h && h.isInput) {
              th.innerHTML = '<input type="text" id="name-' + i + '" value="' + (h.value || "") + '" onblur="setName(' + i + ')">';
            } else {
              th.innerHTML = (h && h.value != null) ? h.value : th.innerHTML;
            }
          }

          // Clear existing rows
          while (table.rows.length > 2) table.deleteRow(-1);

          // Restore rows
          if (data.rows && data.rows.length) {
            data.rows.forEach(function(r) {
              var row = table.insertRow(-1);
              var checkCell = row.insertCell(0);
              checkCell.innerHTML = r.check || '';

              for (var i = 1; i <= 4; i++) {
                var cell = row.insertCell(i);
                cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
                var inp = cell.firstChild;
                inp.value = (r.scores && r.scores[i - 1] != null) ? r.scores[i - 1] : "";
                inp.addEventListener("input", saveGame);
              }
            });
          }

          completeScores();
          saveGame();
          return;
        }
      } catch (e) {}
    }

    // Case B: lỡ lưu dạng HTML <table...>
    if (trimmed[0] === "<" && trimmed.toLowerCase().indexOf("<table") !== -1) {
      try {
        var wrapper = document.createElement("div");
        wrapper.innerHTML = trimmed;
        var newTable = wrapper.querySelector("table");
        if (newTable && newTable.id === "scoreTable") {
          table.replaceWith(newTable);
          attachAutoSaveToExistingInputs();
          completeScores();
          saveGame();
          return;
        }
      } catch (e2) {}
    }

    // Case C: dữ liệu rác
    localStorage.removeItem(STORAGE_KEY);
  }

  function resetGame() {
    if (!confirm("Bạn có chắc muốn reset để tạo game mới và xoá hết dữ liệu cũ không?")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  }

  function setName(index) {
    var input = document.getElementById("name-" + index);
    var name = input.value;
    var th = input.parentElement;
    th.innerHTML = name;
    saveGame();
  }

  function enterPoints() {
    var table = document.getElementById("scoreTable");
    var row = table.insertRow(-1);
    var checkCell = row.insertCell(0);
    checkCell.innerHTML = '';
    for (var i = 1; i <= 4; i++) {
      var cell = row.insertCell(i);
      cell.innerHTML = '<input type="number" class="score-input-' + (i - 1) + '">';
      cell.firstChild.addEventListener("input", saveGame);
    }
    saveGame();
  }

  function completeScores() {
    var totals = [0, 0, 0, 0];
    var table = document.getElementById("scoreTable");
    var rowCount = table.rows.length;
    var error = false;

    for (var i = 0; i < 4; i++) {
      var inputs = document.getElementsByClassName("score-input-" + i);
      totals[i] = Array.from(inputs).reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
      var totalElement = document.getElementById("total-score-" + i);
      totalElement.innerText = totals[i];
      if (totals[i] > 0) totalElement.className = 'score-positive total-score';
      else if (totals[i] < 0) totalElement.className = 'score-negative total-score';
      else totalElement.className = 'score-neutral total-score';
    }

    for (var rowIdx = 2; rowIdx < rowCount; rowIdx++) {
      var row = table.rows[rowIdx];
      var rowSum = 0;
      for (var colIdx = 1; colIdx <= 4; colIdx++) {
        var cell = row.cells[colIdx].firstChild;
        rowSum += parseInt(cell.value) || 0;
      }
      var checkCell = row.cells[0];
      if (rowSum === 0) checkCell.innerHTML = '<span class="check-positive">O</span>';
      else { checkCell.innerHTML = '<span class="check-negative">X</span>'; error = true; }
    }

    saveGame();
    if (error) alert("Nhập sai rồi bạn êyyyy ^_^");
  }

  // Export Excel: bỏ RowSum + footer report + (UPDATE #2) TOTAL row có màu theo số
  function exportExcel() {
    if (!window.XLSX) {
      alert("Không export được vì chưa load được thư viện XLSX.\nHãy chắc chắn repo có file xlsx.min.js và đang mở bằng GitHub Pages.");
      return;
    }

    completeScores();

    var table = document.getElementById("scoreTable");

    function getPlayerName(i) {
      var cell = table.rows[0] && table.rows[0].cells[i + 1];
      if (!cell) return "";
      var inp = cell.querySelector("input");
      var v = inp ? inp.value : (cell.textContent || "");
      return (v || "").toString().trim();
    }

    var names = [getPlayerName(0), getPlayerName(1), getPlayerName(2), getPlayerName(3)];

    // AOA has 5 columns: A..E (check + 4 players)
    var aoa = [];
    aoa.push(["—— Nam Vo ——", "", "", "", ""]);     // row 1 merged A1:E1
    aoa.push(["", "", "", "", ""]);                 // row 2 blank
    aoa.push(["", names[0], names[1], names[2], names[3]]); // row 3 header
    aoa.push([
      "TOTAL",
      document.getElementById("total-score-0").innerText,
      document.getElementById("total-score-1").innerText,
      document.getElementById("total-score-2").innerText,
      document.getElementById("total-score-3").innerText
    ]); // row 4 totals

    for (var r = 2; r < table.rows.length; r++) {
      var row = table.rows[r];
      var check = (row.cells[0].textContent || "").trim();
      var vals = [];
      for (var c = 1; c <= 4; c++) vals.push(parseInt(row.cells[c].firstChild.value) || 0);
      aoa.push([check, vals[0], vals[1], vals[2], vals[3]]);
    }

    // footer note
    var now = new Date();
    function pad2(n){ return String(n).padStart(2,"0"); }
    var stamp = "Report được tạo vào ngày " +
      pad2(now.getDate()) + "/" + pad2(now.getMonth()+1) + "/" + now.getFullYear() + " " +
      pad2(now.getHours()) + ":" + pad2(now.getMinutes()) + ":" + pad2(now.getSeconds());

    aoa.push(["", "", "", "", ""]);        // blank row
    aoa.push(["", "", "", "", stamp]);     // footer row (E..)

    var wb = XLSX.utils.book_new();
    var ws = XLSX.utils.aoa_to_sheet(aoa);

    var maxRow = aoa.length;

    ws["!cols"] = [{wch: 6},{wch: 14},{wch: 14},{wch: 14},{wch: 14}];

    ws["!rows"] = ws["!rows"] || [];
    ws["!rows"][0] = { hpt: 24 };
    ws["!rows"][1] = { hpt: 8 };
    ws["!rows"][2] = { hpt: 18 };
    ws["!rows"][3] = { hpt: 18 };

    ws["!merges"] = ws["!merges"] || [];
    ws["!merges"].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 4 } });

    ws["!sheetViews"] = [{
      showGridLines: false,
      pane: { state: "frozen", ySplit: 3, topLeftCell: "A4", activePane: "bottomLeft" }
    }];

    ws["!autofilter"] = { ref: "A3:E3" };

    function borderThin() {
      return {
        top:    { style: "thin", color: { rgb: "000000" } },
        bottom: { style: "thin", color: { rgb: "000000" } },
        left:   { style: "thin", color: { rgb: "000000" } },
        right:  { style: "thin", color: { rgb: "000000" } }
      };
    }
    function setStyle(addr, s) { if (ws[addr]) ws[addr].s = s; }
    function numColorRgb(n) {
      if (n > 0) return "008000";   // green
      if (n < 0) return "CC0000";   // red
      return "808080";             // grey
    }

    // A1 header (no border)
    setStyle("A1", {
      font: { bold: true, sz: 16 },
      alignment: { horizontal: "center", vertical: "center" },
      fill: { patternType: "solid", fgColor: { rgb: "F2F2F2" } }
    });

    // Content area only (exclude last 2 footer rows)
    var footerRows = 2;
    var contentStartR = 2;                   // row 3
    var contentEndR   = (maxRow - 1) - footerRows;
    var contentStartC = 0;
    var contentEndC   = 4;

    // row 3 header
    for (var cc = contentStartC; cc <= contentEndC; cc++) {
      var addrH = XLSX.utils.encode_cell({ r: 2, c: cc });
      setStyle(addrH, {
        font: { bold: true },
        alignment: { horizontal: "center", vertical: "center" },
        fill: { patternType: "solid", fgColor: { rgb: "EDEDED" } },
        border: borderThin()
      });
    }

    // row 4 totals (UPDATE #2: thêm màu theo số)
    for (var cc = contentStartC; cc <= contentEndC; cc++) {
      var addrT = XLSX.utils.encode_cell({ r: 3, c: cc });

      var styleT = {
        font: { bold: true },
        alignment: { horizontal: "center", vertical: "center" },
        fill: { patternType: "solid", fgColor: { rgb: "F7F7F7" } },
        border: borderThin()
      };

      // Cells B..E (score totals) => color by sign
      if (cc >= 1 && cc <= 4 && ws[addrT]) {
        ws[addrT].z = "0";
        var num = Number(ws[addrT].v);
        if (!isNaN(num)) {
          styleT.font = Object.assign({}, styleT.font, { color: { rgb: numColorRgb(num) } });
        } else {
          styleT.font = Object.assign({}, styleT.font, { color: { rgb: "808080" } });
        }
      }

      setStyle(addrT, styleT);
    }

    // data rows: zebra + O/X + +/- colors
    for (var rr = 4; rr <= contentEndR; rr++) {
      var isStripe = ((rr - 4) % 2 === 0);
      for (var cc = contentStartC; cc <= contentEndC; cc++) {
        var addrD = XLSX.utils.encode_cell({ r: rr, c: cc });
        if (!ws[addrD]) continue;

        var base = {
          alignment: { horizontal: "center", vertical: "center" },
          border: borderThin()
        };

        if (isStripe) base.fill = { patternType: "solid", fgColor: { rgb: "FBFBFB" } };

        // check column
        if (cc === 0) {
          var v = (ws[addrD].v || "").toString().trim();
          if (v === "O") base.font = { bold: true, color: { rgb: "008000" } };
          else if (v === "X") base.font = { bold: true, color: { rgb: "CC0000" } };
        }

        // score columns
        if (cc >= 1 && cc <= 4) {
          ws[addrD].z = "0";
          var num = Number(ws[addrD].v);
          if (!isNaN(num)) {
            if (num > 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "008000" } });
            if (num < 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "CC0000" } });
            if (num === 0) base.font = Object.assign({}, base.font || {}, { color: { rgb: "808080" } });
          }
        }

        ws[addrD].s = base;
      }
    }

    // footer cell style: right aligned, italic, no border
    var footerRowIndex0 = maxRow - 1;
    var footerCellAddr = XLSX.utils.encode_cell({ r: footerRowIndex0, c: 4 });
    if (ws[footerCellAddr]) {
      ws[footerCellAddr].s = {
        alignment: { horizontal: "right", vertical: "center" },
        font: { italic: true, sz: 11 }
      };
    }

    XLSX.utils.book_append_sheet(wb, ws, "Scores");

    var filename =
      "scores_" +
      now.getFullYear() + "-" + pad2(now.getMonth() + 1) + "-" + pad2(now.getDate()) + "_" +
      pad2(now.getHours()) + pad2(now.getMinutes()) +
      ".xlsx";

    XLSX.writeFile(wb, filename);
  }

  window.addEventListener("load", function() {
    loadGame();
    attachAutoSaveToExistingInputs();
  });

  window.addEventListener("beforeunload", saveGame);
</script>

</body>
</html>
